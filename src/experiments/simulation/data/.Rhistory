xlab("p in zone") + ylab("log lh")
n_zone_C <- n_rest_C <- n_all/2
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"c: c")) +
xlab("p in zone") + ylab("log lh")
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'c'='pink'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"c: c")) +
xlab("p in zone") + ylab("log lh")
ll_C
ll_C
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C"))
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
n_rest_C <- (1-r)*n_all
r <- 0.3
n_zone_C <- r*n_all
n_rest_C <- (1-r)*n_all
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
r <- 0.1
n_zone_C <- r*n_all
n_rest_C <- (1-r)*n_all
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
n_rest_A <- 900
k_rest_A <- n_rest_A/2
# Small informative zone (with a distribution that is distinct from the background)
n_zone_A <- 100
k_zone_A <- seq(2, 49, 2)
p_zone_A <- k_zone_A/n_zone_A
ll_zone_A <- k_zone_A * log(p_zone_A) + (n_zone_A - k_zone_A) * log(1-p_zone_A)
p_rest_A <- k_rest_A/n_rest_A
ll_rest_A <- k_rest_A * log(p_rest_A) + (n_rest_A - k_rest_A) * log(1-p_rest_A)
ll_A <- data.frame(lh=ll_zone_A + ll_rest_A, p=p_zone_A)
# Scenario B:
# Distribute data evenly, such that zone and background are equally large and equally uninformative
n_all <- n_rest_A + n_zone_A
k_all <- k_rest_A + k_zone_A
n_zone_B <- n_rest_B <- n_all/2
k_zone_B <- k_rest_B <- k_all/2
p_zone_B <- k_zone_B/n_zone_B
ll_zone_B <- k_zone_B * log(p_zone_B) + (n_zone_B - k_zone_B) * log(1-p_zone_B)
p_rest_B <- k_rest_B/n_rest_B
ll_rest_B <- k_rest_B * log(p_rest_B) + (n_rest_B - k_rest_B) * log(1-p_rest_B)
ll_B <- data.frame(lh=ll_zone_B + ll_rest_B, p=p_zone_A)
# Scenario C:
r <- 0.1
n_zone_C <- r*n_all
n_rest_C <- (1-r)*n_all
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
n_rest_A <- 900
k_rest_A <- n_rest_A/2
# Small informative zone (with a distribution that is distinct from the background)
n_zone_A <- 100
k_zone_A <- seq(2, 49, 2)
p_zone_A <- k_zone_A/n_zone_A
ll_zone_A <- k_zone_A * log(p_zone_A) + (n_zone_A - k_zone_A) * log(1-p_zone_A)
p_rest_A <- k_rest_A/n_rest_A
ll_rest_A <- k_rest_A * log(p_rest_A) + (n_rest_A - k_rest_A) * log(1-p_rest_A)
ll_A <- data.frame(lh=ll_zone_A + ll_rest_A, p=p_zone_A)
# Scenario B:
# Distribute data evenly, such that zone and background are equally large and equally uninformative
n_all <- n_rest_A + n_zone_A
k_all <- k_rest_A + k_zone_A
n_zone_B <- n_rest_B <- n_all/2
k_zone_B <- k_rest_B <- k_all/2
p_zone_B <- k_zone_B/n_zone_B
ll_zone_B <- k_zone_B * log(p_zone_B) + (n_zone_B - k_zone_B) * log(1-p_zone_B)
p_rest_B <- k_rest_B/n_rest_B
ll_rest_B <- k_rest_B * log(p_rest_B) + (n_rest_B - k_rest_B) * log(1-p_rest_B)
ll_B <- data.frame(lh=ll_zone_B + ll_rest_B, p=p_zone_A)
# Scenario C:
r <- 0.1
n_zone_C <- r*n_all
n_rest_C <- (1-r)*n_all
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
# Scenario A:
# Large uninformative background
n_rest_A <- 900
k_rest_A <- n_rest_A/2
# Small informative zone (with a distribution that is distinct from the background)
n_zone_A <- 100
k_zone_A <- seq(2, 49, 2)
p_zone_A <- k_zone_A/n_zone_A
ll_zone_A <- k_zone_A * log(p_zone_A) + (n_zone_A - k_zone_A) * log(1-p_zone_A)
p_rest_A <- k_rest_A/n_rest_A
ll_rest_A <- k_rest_A * log(p_rest_A) + (n_rest_A - k_rest_A) * log(1-p_rest_A)
ll_A <- data.frame(lh=ll_zone_A + ll_rest_A, p=p_zone_A)
# Scenario B:
# Distribute data evenly, such that zone and background are equally large and equally uninformative
n_all <- n_rest_A + n_zone_A
k_all <- k_rest_A + k_zone_A
n_zone_B <- n_rest_B <- n_all/2
k_zone_B <- k_rest_B <- k_all/2
p_zone_B <- k_zone_B/n_zone_B
ll_zone_B <- k_zone_B * log(p_zone_B) + (n_zone_B - k_zone_B) * log(1-p_zone_B)
p_rest_B <- k_rest_B/n_rest_B
ll_rest_B <- k_rest_B * log(p_rest_B) + (n_rest_B - k_rest_B) * log(1-p_rest_B)
ll_B <- data.frame(lh=ll_zone_B + ll_rest_B, p=p_zone_A)
# Scenario C:
r <- 0.2
n_zone_C <- r*n_all
n_rest_C <- (1-r)*n_all
q2 <- n_rest_C / n_rest_A
q1 <- 1 - q2
k_zone_C <- k_zone_A + q1 * k_rest_A
k_rest_C <- q2 * k_rest_A
p_zone_C <- k_zone_C/n_zone_C
ll_zone_C <- k_zone_C * log(p_zone_C) + (n_zone_C - k_zone_C) * log(1-p_zone_C)
p_rest_C <- k_rest_C/n_rest_C
ll_rest_C <- k_rest_C * log(p_rest_C) + (n_rest_C - k_rest_C) * log(1-p_rest_C)
ll_C <- data.frame(lh=ll_zone_C + ll_rest_C, p=p_zone_A)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
View(get_upper_tri)
View(get_upper_tri)
View(get_upper_tri)
View(get_upper_tri)
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: C")) +
xlab("p in zone") + ylab("log lh")
ggplot() +
geom_line(data=ll_A, aes(x=p, y=lh, color="A")) +
geom_line(data=ll_B, aes(x=p, y=lh, color="B")) +
geom_line(data=ll_C, aes(x=p, y=lh, color="C")) +
scale_color_manual(name = "Scenario", values = c('A' = 'darkblue', 'B' = 'red', 'C'='green'),
labels = c("A: one small informative, one large uninformative",
"B: two medium-sized moderately informative",
"C: teo medium-sized, one more informative, one less informative")) +
xlab("p in zone") + ylab("log lh")
# Historical GIS - Part 1
# Load dplyr
# install.packages("dplyr")
# install.packages("leaflet")
# Load package dplyr
library(dplyr)
# Import data
viking_raids <- read.csv(file = "../data/viking_raids.csv", header = T, sep = ",")
# Manipulate data frames
# filter
filter(viking_raids, year > 845)
filter(viking_raids, year == 851 | year == 857)
filter(viking_raids, year == 845 & location == "Paris")
# arrange
arrange(viking_raids, year)
arrange(viking_raids, desc(year))
# select
select(viking_raids, year, location)
select(viking_raids, year, location) %>% filter(year == 851)
# mutate
mutate(viking_raids, decade = trunc((year-1)/10)*10)
# summarize
summarise(viking_raids, first_year = min(year))
# group_by
group_by(viking_raids, year) %>%
summarise(loc_count = n())
# Load leaflet
library(leaflet)
# Map the Viking raids and label the locations
map <- leaflet(viking_raids) %>% addTiles()
map %>%
addCircleMarkers(~longitude, ~latitude, label = ~location)
# Different markers for raids with approximate and exact location
col_pal <- colorFactor(c("blue", "red"), domain = c("0", "1"))
map <- map %>%
addCircleMarkers(~longitude, ~latitude, popup = ~location,
color = ~col_pal(loc_approx))
# Add legend
map %>%
addLegend(labels = c("approximate", "exact"),
colors = c(c("red", "blue")),
title = "Approximate location?")
# Historical GIS - Part 1
# Load dplyr
# install.packages("dplyr")
# install.packages("leaflet")
# Load package dplyr
library(dplyr)
# Import data
viking_raids <- read.csv(file = "../data/viking_raids.csv", header = T, sep = ",")
# Manipulate data frames
# filter
filter(viking_raids, year > 845)
filter(viking_raids, year == 851 | year == 857)
filter(viking_raids, year == 845 & location == "Paris")
# arrange
arrange(viking_raids, year)
arrange(viking_raids, desc(year))
# select
select(viking_raids, year, location)
select(viking_raids, year, location) %>% filter(year == 851)
# mutate
mutate(viking_raids, decade = trunc((year-1)/10)*10)
# summarize
summarise(viking_raids, first_year = min(year))
# group_by
group_by(viking_raids, year) %>%
summarise(loc_count = n())
# Load leaflet
library(leaflet)
# Map the Viking raids and label the locations
map <- leaflet(viking_raids) %>% addTiles()
map %>%
addCircleMarkers(~longitude, ~latitude, label = ~location)
# Different markers for raids with approximate and exact location
col_pal <- colorFactor(c("blue", "red"), domain = c("0", "1"))
map <- map %>%
addCircleMarkers(~longitude, ~latitude, popup = ~location,
color = ~col_pal(loc_approx))
# Add legend
map %>%
addLegend(labels = c("approximate", "exact"),
colors = c(c("red", "blue")),
title = "Approximate location?")
library(dplyr)
viking_raids <- read.csv(file = "../data/viking_raids.csv", header = T, sep = ",")
library(lattice)
meuse
data(meuse)
lattice::meuse
library(sp)
meuse
data("meuse")
meuse
set.seed(123)
y = rnorm(50, 40, 10)
hist(y)
#Sample a realization from the distribution of mu given
#data (y), assumed known data variance (sigma2), prior mean (mu0), and prior variance (var0).
post_mu = function(y, sigma2, mu0, var0) {
a = length(y) / sigma2 + 1 / var0
b = sum(y) / sigma2 + mu0 / var0
b = b / a
rnorm(1, b, sqrt(1/a))
}
y
iterations = 10
sigma2 = rep(0, iterations)
sigma2
sigma2[1] = 20
sigma2
mu0=0
var0=1000
post_mu(y, sigma2[i - 1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
post_mu(y, sigma2[1], mu0, var0)
debug(post_mu)
post_mu(y, sigma2[1], mu0, var0)
a
length(y) / sigma2 + 1 / var0
length(y)
a = length(y) / sigma2 + 1
a
a = length(y) / sigma2 + 1 / var0
a
b = sum(y) / sigma2 + mu0 / var0
b
b = b/a
b
rnorm(1, b, sqrt(1/a))
sum(y)
y
sum(y) / sigma2
a = length(y) / sigma2 + 1 / var0
a
post_mu = function(y, sigma2, mu0, var0) {
a = length(y) / sigma2 + 1 / var0
b = sum(y) / sigma2 + mu0 / var0
b = b / a
rnorm(1, b, sqrt(1/a))
}
?rnorm
rgamma
?rgamma
getPosteriorSamples = function(iterations, mu0, var0, a0, b0) {
iterations = iterations + 1 #add space for starting values
mu = rep(0, iterations)
sigma2 = rep(0, iterations)
#start values
mu[1] = 0
sigma2[1] = 20
for (i in 2:iterations) {
mu[i] = post_mu(y, sigma2[i - 1], mu0, var0)
sigma2[i] = post_sigma2(y, mu[i], a0, b0)
}
m = cbind(mu, sigma2)
m[-1,] #strip off starting values
}
theta_post = getPosteriorSamples(iterations=1000, mu0=0, var0=1000, a0=0.1, b0=0.1)
set.seed(123)
y = rnorm(50, 40, 10)
hist(y)
theta_post = getPosteriorSamples(iterations=1000, mu0=0, var0=1000, a0=0.1, b0=0.1)
post_sigma2 = function(y, mu, a0, b0) {
SSE = sum((y - mu)^2)
a = a0 + length(y)/2
b = b0 + SSE / 2
r = rgamma(1, a, b)
1/r
}
theta_post = getPosteriorSamples(iterations=1000, mu0=0, var0=1000, a0=0.1, b0=0.1)
theta_post
theta_hat = apply(theta_post, 2, mean)
theta_hat
LL =  logLikelihood(y, theta_hat)
logLikelihood = function(y, theta) {
#Get the individual parameters out of theta.
mu = theta[1]
sigma2 = theta[2]
#sum of log likelihoods = log of product of likelihoods
sum(dnorm(y, mu, sqrt(sigma2), log=TRUE) )
}
LL =  logLikelihood(y, theta_hat)
LL
logLikelihood(y, theta_post)
theta_post
logLikelihood(y, theta_hat)
debug(logLikelihood)
logLikelihood(y, theta_post)
mu
theta
mu[1]
install.packages("RSQL")
install.packages("RPostgreSQL")
library(RPostgres)
library(DBI)
library(RPostgreSQL)
pw<- {"letsfindthemcontactzones"}
pw<- {'letsfindthemcontactzones'}
con <- dbConnect(RPostgres::Postgres(), host='limits.geo.uzh.ch',
port='5432', dbname='limits-db', port=5432, user='contact_zones', password=pw)
pw<- {'letsfindthemcontactzones'}
con <- dbConnect(dbDriver("PostgreSQL"), host='limits.geo.uzh.ch',
port='5432', dbname='limits-db',
port=5432, user='contact_zones', password=pw)
rm(pw) # removes the password
dbExistsTable(con, "cz_sim.contact_zones_raw")
con <- dbConnect(dbDriver("PostgreSQL"), host='limits.geo.uzh.ch',
port='5432', dbname='limits-db',
port=5432, user='contact_zones', password=pw)
con <- dbConnect(dbDriver("PostgreSQL"), host='limits.geo.uzh.ch',
dbname='limits-db',
port=5432, user='contact_zones', password=pw)
pw <- {'letsfindthemcontactzones'}
con <- dbConnect(dbDriver("PostgreSQL"), host='limits.geo.uzh.ch',
dbname='limits-db',
port=5432, user='contact_zones', password=pw)
dbExistsTable(con, "cz_sim.contact_zones_raw")
drv <- dbDriver("PostgreSQL")# open the connection using user, passsword, etc.,
df <- dbGetQuery(con, statement = paste("SELECT gid, mx AS x, my AS y FROM cz_sim.contact_zones_raw ORDER BY gid;"))
rs <- dbSendQuery(con, statement = paste("SELECT gid, mx AS x, my AS y FROM cz_sim.contact_zones_raw ORDER BY gid;"))
sites <- fetch(rs, n = -1)
sites
getwd()
sewd("C:\Users\ranacher\Desktop\limits\sbayes\experiments\simulation\data")
sewd("C:/Users/ranacher/Desktop/limits/sbayes/experiments/simulation/data")
write.csv(sites, file="simulated_sites.csv")
setwd("C:/Users/ranacher/Desktop/limits/sbayes/experiments/simulation/data")
write.csv(sites, file="simulated_sites.csv")
?write.csv
write.csv(sites, file="simulated_sites.csv", row.names = F)
drv <- dbDriver("PostgreSQL")# open the connection using user, passsword, etc.,
rs <- dbSendQuery(con, statement = paste("SELECT gid, mx AS x, my AS y FROM cz_sim.contact_zones_raw ORDER BY gid;"))
sites <- fetch(rs, n = -1)
setwd("C:/Users/ranacher/Desktop/limits/sbayes/experiments/simulation/data")
write.csv(sites, file="simulated_sites.csv", row.names = F)
sites
rs2 <- dbSendQuery(con, statement = paste("SELECT gid, cz FROM cz_sim.contact_zones_raw ORDER BY gid;"))
cz <- fetch(rs2, n = -1)
cz
# Connect to DB
pw <- {'letsfindthemcontactzones'}
con <- dbConnect(dbDriver("PostgreSQL"), host='limits.geo.uzh.ch',
dbname='limits-db',
port=5432, user='contact_zones', password=pw)
rm(pw) # removes the password
dbExistsTable(con, "cz_sim.contact_zones_raw")
drv <- dbDriver("PostgreSQL")# open the connection using user, passsword, etc.,
# Retrieve sites
rs <- dbSendQuery(con, statement = paste("SELECT gid, mx AS x, my AS y, cz FROM cz_sim.contact_zones_raw ORDER BY gid;"))
sites <- fetch(rs, n = -1)
setwd("C:/Users/ranacher/Desktop/limits/sbayes/experiments/simulation/data")
write.csv(sites, file="simulated_sites.csv", row.names = F)
sites
nrow(sites)
sites["cz"] == 0
sites["cz"] >= 100
sites[sites["cz"] >= 100, ]
sites[sites["cz"] >= 100, "cz"]
sites[sites["cz"] >= 100, "cz"] <- 0
setwd("C:/Users/ranacher/Desktop/limits/sbayes/experiments/simulation/data")
write.csv(sites, file="simulated_sites.csv", row.names = F)
